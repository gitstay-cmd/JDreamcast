void ADD(CPU *cpu, long m, long n) /* ADD Rm, Rn */
{
    R[n] += R[m];
    cpu->PC+=2;
}

void ADDI(CPU *cpu, long i, long n) /* ADD #imm,Rn */
{
    if ((i&0x80) == 0)
          R[n]+=(0x000000FF & (long)i);
    else  R[n]+=(0xFFFFFF0 | (long)i);
    cpu->PC+=2; 
}

void ADDC(CPU *cpu, long m, long n) /* ADDC Rm, Rn */
{
    unsigned long tmp0, tmp1; 
    tmp1=R[n]+R[m];
    tmp0=R[n];
    R[n]=tmp1+T;
    if (tmp0>tmp1) T=1;
    else T=0;
    if (tmp1>R[n]) T=1;
    cpu->PC+=2;
}

void ADDV(CPU *cpu, long m, long n) /* ADDV Rm,Rn */
{
    long dest,src,ans;

    if ((long)R[n]>=0) dest=0;
    else dest=1;
    if ((long)R[m]>=0) src=0;
    else src=1;
    src+=dest;
    R[n]+=R[m];
    if ((long)R[n]>=0) ans=0;
    else ans=1;
    ans+=dest;
    if (src==0 || src==2) {
        if (ans==1) T=1;
        else T=0;
    }
    else T=0;
    cpu->PC+=2;
}

void AND(CPU *cpu, long m, long n) /* AND Rm, Rn */
{
    R[n]&=R[m];
    cpu->PC+=2;
}

void ANDI(CPU *cpu, long i) /* AND #imm,R0 */
{
    R[0]&=(0x000000FF & (long)i);
    cpu->PC+=2;
}

void ANDM(CPU *cpu, long i) /* AND.B #imm,@(R0,GBR) */
{
    long temp;

    temp=(long)read_byte(GBR+R[0]);
    temp&=(0x000000FF & (long)i);
    Write_Byte(GBR+R[0],temp);
    cpu->PC+=2;
}

void BF(CPU *cpu, int d) /* BF disp */
{
    int disp;

    if((d&0x80)==0)
            cpu->disp=(0x000000FF & d);
    else
            cpu->disp=(0xFFFFFF00 | d);
    if (T==0)
            cpu->PC=cpu->PC+4+(disp<<1);
    else    cpu->PC+=2;
}

void BFS(CPU *cpu, int d) /* BFS disp */
{
    if (T==0)
            execute_instruction(cpu);
            BF(cpu, d);
    else  cpu->PC+=4;
}

void BRA(CPU *cpu, int d) /* BRA label */
{ 
    int disp;

    if((d&0x80)==0)
            cpu->disp=(0x000000FF & d);
    else
            cpu->disp=(0xFFFFFF00 | d);

    execute_instruction(cpu);
    cpu->PC=cpu->PC+4+(disp<<1);
}

void BRAF(CPU *cpu, int n) /* BRAF Rn */
{
    unsigned int temp;

    temp=cpu->PC;
    execute_instruction(cpu);
    cpu->PC=cpu->PC+4+R[n];
}

void BSR(CPU *cpu, int d) /* BSR disp */
{
    int disp;
    unsigned int temp;

    if ((d&0x800)==0)
        disp=(0x00000FFF & d);
    else disp=(0xFFFFF000 | d);
    cpu->PR=cpu->PC+4;
    execute_instruction(cpu);
    cpu->PC=cpu->PC+4+(disp<<1);
}

void BSRF(CPU *cpu, int n) /* BSRF Rn */
{
    unsigned int temp;

    temp=cpu->PC;
    cpu->PR=cpu->PC+4;
    execute_instruction(cpu);
    cpu->PC=cpu->PC+4+R[n];
}

void BT(CPU *cpu, int d) /* BT disp */
{
    int disp;

    if  ((d&0x80)==0)
          disp=(0x0000000FF & d);
    else  disp=(0xFFFFFF00 | d);
    if  (T==1)
          cpu->pc=cpu->pc+4+(disp<<1);
    else cpu->PC+=2;
}

void BTS(CPU *cpu, int d) /* BTS disp */
{
    if (T==1)
            execute_instruction(cpu);
            BT(cpu, d);
    else  cpu->PC+=4;
 
}

void CLRMAC(CPU *cpu) /* CLRMAC */
{
    cpu->MACH=0;
    cpu->MACL=0;
    cpu->PC+=2;
}

void CLR(CPU *cpu) /* CLRS */
{
    cpu->S=0;
    cpu->PC+=2;
}

void CLRT(CPU *cpu) /* CLRS */
{
    cpu->T=0;
    cpu->PC+=2;
}

void CMPEQ(CPU *cpu, long m, long n) /* CMP_EQ Rm,Rn */
{
    if (R[n]==R[m]) T=1;
    else T=0;
    cpu->PC+=2;
}

void CMPGE(CPU *cpu, long m, long n) /* CMP_GE Rm,Rn */
{
    if ((long)R[n]>=(long)R[m]) T=1;
    else T=0;
    cpu->PC+=2;
}

void CMPGT(CPU *cpu, long m, long n) /* CMP_GT Rm,Rn */
{
    if ((long)R[n]>(long)R[m]) T=1;
    else T=0;
    cpu->PC+=2;
}

void CMPHI(CPU *cpu, long m, long n) /* CMP_HI Rm,Rn */
{
    if ((unsigned long)R[n]>(unsigned long)R[m]) T=1;
    else T=0;
    cpu->PC+=2;
}

void CMPHS(CPU *cpu, long m, long n) /* CMP_HS Rm,Rn */
{
    if ((unsigned long)R[n]>=(unsigned long)R[m]) T=1;
    else T=0;
    cpu->PC+=2;
}
CMPPL(long n) /* CMP_PL Rn */
{
    if ((long)R[n]>0) T=1;
    else T=0;
    cpu->PC+=2;
}
CMPPZ(long n) /* CMP_PZ Rn */
{
 if ((long)R[n]>=0) T=1;
 else T=0;
 PC+=2;
}

void CMPSTR(long m, long n) /* CMP_STR Rm,Rn */
{
    unsigned long temp;
    long HH,HL,LH,LL;
    temp=R[n]^R[m];
    HH=(temp&0xFF000000)>>24;
    HL=(temp&0x00FF0000)>>16;
    LH=(temp&0x0000FF00)>>8;
    LL=temp&0x000000FF;
    HH=HH&&HL&&LH&&LL;
    if (HH==0) T=1;
    else T=0;
    PC+=2;
}

void CMPIM(CPU *cpu, long i) /* CMP_EQ #imm,R0 */
{
    long imm;
    if ((i&0x80)==0) imm=(0x000000FF & (long i));
    else imm=(0xFFFFFF00 | (long i));
    if (R[0]==imm) T=1;
    else T=0;
    cpu->PC+=2;
}

void DIV0S(CPU *cpu, long m, long n) /* DIV0S Rm,Rn */
{
    if ((R[n] & 0x80000000)==0) Q=0;
    else Q=1;
    if ((R[m] & 0x80000000)==0) M=0;
    else M=1;
    T=!(M==Q);
    cpu->PC+=2;
}

void DIV0U(CPU *cpu) /* DIV0U */
{
    M=Q=T=0;
    PC+=2;
}

void DIV1(CPU *cpu, long m, long n) /* DIV1 Rm,Rn */
{
    unsigned long tmp0, tmp2;
    unsigned char old_q, tmp1;
    old_q=Q;
    Q=(unsigned char)((0x80000000 & R[n])!=0);
    tmp2= R[m];
    R[n]<<=1;
    R[n]|=(unsigned long)T;
    switch(old_q){
        case 0:switch(M){
            case 0:
                tmp0=R[n];
                R[n]-=tmp2;
                tmp1=(R[n]>tmp0);
                switch(Q){
                    case 0:Q=tmp1;
                    break;
                    case 1:Q=(unsigned char)(tmp1==0);
                    break;
                }
            break;
            case 1:tmp0=R[n];
                R[n]+=tmp2;
                tmp1=(R[n]<tmp0);
                switch(Q){
                    case 0:Q=(unsigned char)(tmp1==0);
                    break;
                    case 1:Q=tmp1;
                    break;
                }
            break;
        }
        break;
        case 1:switch(M){
            case 0:tmp0=R[n];
                R[n]+=tmp2;
                tmp1=(R[n]<tmp0);
                switch(Q){
                    case 0:Q=tmp1;
                    break;
                    case 1:Q=(unsigned char)(tmp1==0);
                    break;
                }
            break;
            case 1:tmp0=R[n];
                R[n]-=tmp2;
                tmp1=(R[n]>tmp0);
                switch(Q){
                    case 0:Q=(unsigned char)(tmp1==0);
                    break;
                    case 1:Q=tmp1;
                    break;
                }
            break;
        }
        break;
    }
    T=(Q==M);
    PC+=2;
}

void DMULS(CPU *cpu, long m, long n) /* DMULS.L Rm,Rn */
{
    unsigned long RnL,RnH,RmL,RmH,Res0,Res1,Res2;
    unsigned long temp0,temp1,temp2,temp3;
    long tempm,tempn,fnLmL;
    tempn=(long)R[n];
    tempm=(long)R[m];
    if (tempn<0) tempn=0-tempn;
    if (tempm<0) tempm=0-tempm;
    if ((long)(R[n]^R[m])<0) fnLmL=-1;
    else fnLmL=0;
    temp1=(unsigned long)tempn;
    temp2=(unsigned long)tempm;
    RnL=temp1&0x0000FFFF;
    RnH=(temp1>>16)&0x0000FFFF;
    RmL=temp2&0x0000FFFF;
    RmH=(temp2>>16)&0x0000FFFF;
    temp0=RmL*RnL;
    temp1=RmH*RnL;
    temp2=RmL*RnH;
    temp3=RmH*RnH;
    Res2=0;
    Res1=temp1+temp2;
    if (Res1<temp1) Res2+=0x00010000;
    temp1=(Res1<<16)&0xFFFF0000;
    Res0=temp0+temp1;
    if (Res0<temp0) Res2++;
    Res2=Res2+((Res1>>16)&0x0000FFFF)+temp3;
    if (fnLmL<0) {
        Res2=~
        Res2;
        if (Res0==0)
            Res2++;
        else
            Res0=(~Res0)+1;
    }
    MACH=Res2;
    MACL=Res0;
    PC+=2;
}

void DMULU(CPU *cpu, long m, long n) /* DMULU.L Rm,Rn */
{
    unsigned long RnL,RnH,RmL,RmH,Res0,Res1,Res2;
    unsigned long temp0,temp1,temp2,temp3;
    RnL=R[n]&0x0000FFFF;
    RnH=(R[n]>>16)&0x0000FFFF;
    RmL=R[m]&0x0000FFFF;
    RmH=(R[m]>>16)&0x0000FFFF;
    temp0=RmL*RnL;
    temp1=RmH*RnL;
    temp2=RmL*RnH;
    temp3=RmH*RnH;
    Res2=0
    Res1=temp1+temp2;
    if (Res1<temp1) Res2+=0x00010000;
    temp1=(Res1<<16)&0xFFFF0000;
    Res0=temp0+temp1;
    if (Res0<temp0) Res2++;
    Res2=Res2+((Res1>>16)&0x0000FFFF)+temp3;
    MACH=Res2;
    MACL=Res0;
    cpu->PC+=2;
}

void DT(CPU *cpu, long n)/* DT Rn */
{
    R[n]--;
    if (R[n]==0) T=1;
    else T=0;
    cpu->PC+=2;
}

void EXTSB(CPU *cpu, long m, long n) /* EXTS.B Rm,Rn */
{
    R[n]=R[m];
    if ((R[m]&0x00000080)==0) R[n]&=0x000000FF;
    else R[n]|=0xFFFFFF00;
    cpu->PC+=2;
}

void EXTSW(CPU *cpu, long m, long n) /* EXTS.W Rm,Rn */
{
    R[n]=R[m];
    if ((R[m]&0x00008000)==0) R[n]&=0x0000FFFF;
    else R[n]|=0xFFFF0000;
    cpu->PC+=2;
}

void EXTUB(CPU *cpu, long m, long n) /* EXTU.B Rm,Rn */
{
    R[n]=R[m];
    R[n]&=0x000000FF;
    cpu->PC+=2;
}

void EXTUW(CPU *cpu, long m, long n) /* EXTU.W Rm,Rn */
{
    R[n]=R[m];
    R[n]&=0x0000FFFF;
    cpu->PC+=2;
}

void FABS (CPU *cpu, int n){
    FR[n] = FR[n] & 0x7fffffff;
    cpu->PC += 2;
}

void FADD (CPU *cpu, int m, int n)
{
    pc += 2;
    clear_cause();
    if((data_type_of(m) == sNaN) ||
    (data_type_of(n) == sNaN)) invalid(n);
    else if((data_type_of(m) == qNaN) ||
    (data_type_of(n) == qNaN)) qnan(n);
    else if((data_type_of(m) == DENORM) ||
    (data_type_of(n) == DENORM)) set_E();
    else switch (data_type_of(m)){
            case NORM: switch (data_type_of(n)){
            case NORM: normal_faddsub(m,n,ADD); break;
            case PZERO:
            case NZERO:register_copy(m,n); break;
            default: break;
            } break;
            case PZERO: 
                switch (data_type_of(n)){
                    case NZERO: zero(n,0); break;
                    default: break;
                } 
            break;
            case NZERO: break;
            case PINF: 
            switch (data_type_of(n)){
                case NINF: invalid(n); break;
                default: inf(n,0); break;
            } break;
            case NINF: 
                switch (data_type_of(n)){
                    case PINF: invalid(n); break;
                    default: inf(n,1); break;
                } break;
            default:
            break;
    }
}

void FCMP_EQ(CPU *cpu, int m, int n) /* FCMP/EQ FRm,FRn */
{
    cpu->PC += 2;
    clear_cause();
    if(fcmp_chk (m,n) == INVALID) fcmp_invalid();
    else if(fcmp_chk (m,n) == EQ) T = 1;
    else T = 0;
}

void FCMP_GT(CPU *cpu int m,int n) /* FCMP/GT FRm,FRn */
{
    cpu->PC += 2;
    clear_cause();
    if ((fcmp_chk (m,n) == INVALID) ||
    (fcmp_chk (m,n) == UO)) fcmp_invalid();
    else if(fcmp_chk (m,n) == GT) T = 1;
    else T = 0;
}

void int fcmp_chk (CPU *cpu, int m, int n)
{ 
    if((data_type_of(m) == sNaN) || (data_type_of(n) == sNaN)) return(INVALID);
    else if((data_type_of(m) == qNaN) || (data_type_of(n) == qNaN)) return(UO);
    else switch(data_type_of(m)){
        case NORM: switch(data_type_of(n)){
            case PINF :return(GT); break;
            case NINF :return(LT); break;
            default: break;
        } break;
        case PZERO:
        case NZERO: switch(data_type_of(n)){
            case PZERO :
            case NZERO :return(EQ); break;
            default: break;
        } break;
        case PINF : switch(data_type_of(n)){
            case PINF :return(EQ); break;
            default:return(LT); break;
        } break;
        case NINF : switch(data_type_of(n)){
            case NINF :return(EQ); break;
            default:return(GT); break;
        } break;
    }
    if(FPSCR_PR == 0) {
        if(FR[n] == FR[m]) return(EQ);
        else if(FR[n] > FR[m]) return(GT);
            else return(LT);
    }else {
        if(DR[n>>1] == DR[m>>1]) return(EQ);
        else if(DR[n>>1] > DR[m>>1]) return(GT);
        else return(LT);
    }
}

void fcmp_invalid(CPU *cpu)
{
    set_V(); if((FPSCR & ENABLE_V) == 0) T = 0;
    else fpu_exception_trap();
}

void FCNVDS(CPU *cpu, int m, float *FPUL){
    switch(FPSCR.PR){
        case 0: undefined_operation(); /* reserved */
        case 1: fcnvds(m, *FPUL); break; /* FCNVDS */
        default: break;
    }
}

void fcnvds(CPU *cpu, int m, float *FPUL)
{
    pc += 2;
    clear_cause();
    switch(data_type_of(m, *FPUL)){
        case NORM:
        case PZERO:
        case NZERO: normal_ fcnvds(m, *FPUL); break;
        case DENORM: set_E();
        case PINF: *FPUL = 0x7f800000; break;
        case NINF: *FPUL = 0xff800000; break;
        case qNaN: *FPUL = 0x7fbfffff; break;
        case sNaN: set_V();
            if((FPSCR & ENABLE_V) == 0) *FPUL = 0x7fbfffff;
            else fpu_exception_trap(); break;
    }
}

void normal_fcnvds(CPU *cpu, int m, float *FPUL)
{
    int sign;
    float abs;
    union {
        float f;
        int l;
    } dstf,tmpf;
    union {
        double d;
        int l[2];
    } dstd;
    dstd.d = DR[m>>1];
    if(dstd.l[1] & 0x1fffffff) set_I();
    if(FPSCR_RM == 1) dstd.l[1] &= 0xe0000000; /* round toward zero*/
    dstf.f = dstd.d;
    check_single_exception(FPUL, dstf.f);
}

void FCNVSD(CPU *cpu, int n, float *FPUL){
    cpu->PC += 2;
    clear_cause();
    switch(FPSCR_PR){
        case 0: undefined_operation(); /* reserved */
        case 1: fcnvsd (n, *FPUL); break; /* FCNVSD */
    }
}

void fcnvsd(int n, float *FPUL)
{
    switch(fpul_type(FPUL)){
        case PZERO :
        case NZERO :
        case PINF :
        case NINF : DR[n>>1] = *FPUL; break;
        case DENORM : set_E(); break;
        case qNaN : qnan(n); break;
        case sNaN : invalid(n); break;
    }
}

int fpul_type(int *FPUL)
{
    int abs;
    abs = *FPUL & 0x7fffffff;
    if(abs < 0x00800000){
        if((FPSCR_DN == 1) || (abs == 0x00000000)){
            if(sign_of(src) == 0) return(PZERO);
            else return(NZERO);
        }
        else return(DENORM);
    }
    else if(abs < 0x7f800000) return(NORM);
    else if(abs == 0x7f800000) {
        if(sign_of(src) == 0) return(PINF);
        else return(NINF);
    }
    else if(abs < 0x7fc00000) return(qNaN);
    else return(sNaN);
}

void FDIV(CPU *cpu, int m, int n) /* FDIV FRm,FRn */
{
    cpu->PC += 2;
    clear_cause();
    if((data_type_of(m) == sNaN) || (data_type_of(n) == sNaN)) invalid(n);
    else if((data_type_of(m) == qNaN) || (data_type_of(n) == qNaN)) qnan(n);
    else switch (data_type_of(m)){
        case NORM: switch (data_type_of(n)){
            case PINF:
            case NINF: inf(n,sign_of(m)^sign_of(n));break;
            case PZERO:
            case NZERO: zero(n,sign_of(m)^sign_of(n));break;
            case DENORM:set_E(); break;
            default: normal_fdiv(m,n); break;
        } break;
        case PZERO: switch (data_type_of(n)){
            case PZERO:
            case NZERO: invalid(n);break;
            case PINF:
            case NINF: break;
            default: dz(n,sign_of(m)^sign_of(n));break;
        } break;
        case NZERO: switch (data_type_of(n)){
    case PZERO:
 case NZERO: invalid(n); break;
 case PINF: inf(n,1); break;
 case NINF: inf(n,0); break;
 default: dz(FR[n],sign_of(m)^sign_of(n)); break;
 } break;
 case DENORM: set_E(); break;
 case PINF :
 case NINF : switch (data_type_of(n)){
 case DENORM: set_E(); break;
 case PINF:
 case NINF: invalid(n); break;
 default: zero(n,sign_of(m)^sign_of(n));break
 } break;
 }
}
void normal_fdiv(int m,n)
{
union {
 float f;
 int l;
} dstf,tmpf;
union {
 double d;
 int l[2];
} dstd,tmpd;
union {
 int double x;
 int l[4];
} tmpx;
 if(FPSCR_PR == 0) {
 tmpf.f = FR[n]; /* save destination value */
 dstf.f /= FR[m]; /* round toward nearest or even */
 tmpd.d = dstf.f; /* convert single to double */
 tmpd.d *= FR[m];
 if(tmpf.f != tmpd.d) set_I();
 if((tmpf.f < tmpd.d) && (SPSCR_RM == 1))
 dstf.l -= 1; /* round toward zero */
 check_single_exception(&FR[n], dstf.f);
 }else {
 tmpd.d = DR[n>>1]; /* save destination value */
 dstd.d /= DR[m>>1]; /* round toward nearest or even */
 tmpx.x = dstd.d; /* convert double to int double */
 tmpx.x *= DR[m>>1];
 if(tmpd.d != tmpx.x) set_I();
 if((tmpd.d < tmpx.x) && (SPSCR_RM == 1)) {
 dstd.l[1] -= 1; /* round toward zero */
 if(dstd.l[1] == 0xffffffff) dstd.l[0] -= 1;
 }
 check_double_exception(&DR[n>>1], dstd.d);
 }
}

void FIPR(int m,n) /* FIPR FVm,FVn */
{
 if(FPSCR_PR == 0) {
 pc += 2;
 clear_cause();
 fipr(m,n);
 }
 else undefined_operation();
}
void FLDI0(int n)
{
 FR[n] = 0x00000000;
 pc += 2;
}
void FLDI1(int n)
{
 FR[n] = 0x3F800000;
 pc += 2;
}
void FLDS(int m, float *FPUL)
{
 *FPUL = FR[m];
 pc += 2;
}
void FLOAT(int n, float *FPUL)
{
union {
 double d;
 int l[2];
} tmp;
 pc += 2;
 clear_cause();
 if(FPSCR.PR==0){
 FR[n] = *FPUL; /* convert from integer to float */
 tmp.d = *FPUL;
 if(tmp.l[1] & 0x1fffffff) inexact();
 }else {
 DR[n>>1] = *FPUL; /* convert from integer to double */
 }
}
void FMAC(int m,n)
{
 pc += 2;
 clear_cause();
 if(FPSCR_PR == 1) undefined_operation();
 else if((data_type_of(0) == sNaN) ||
 (data_type_of(m) == sNaN) ||
 (data_type_of(n) == sNaN)) invalid(n);
 else if((data_type_of(0) == qNaN) ||
 (data_type_of(m) == qNaN)) qnan(n);
 else if((data_type_of(0) == DENORM) ||
 (data_type_of(m) == DENORM)) set_E();
 else switch (data_type_of(0){
 case NORM: switch (data_type_of(m)){
 case PZERO:
 case NZERO: switch (data_type_of(n)){
 case DENORM: set_E(); break;
 case qNaN: qnan(n); break;
 case PZERO:
 case NZERO: zero(n,sign_of(0)^ sign_of(m)^sign_of(n));
break;
 default: break;
 }
 case PINF:
 case NINF: switch (data_type_of(n)){
 case DENORM: set_E(); break;
 case qNaN: qnan(n); break;
 case PINF:
 case NINF: if(sign_of(0)^ sign_of(m)^sign_of(n)) invalid(n);
 else inf(n,sign_of(0)^ sign_of(m)); break;
 default: inf(n,sign_of(0)^ sign_of(m)); break;
 }
 case NORM: switch (data_type_of(n)){
 case DENORM: set_E(); break;
 case qNaN: qnan(n); break;
 case PINF:
 case NINF: inf(n,sign_of(n)); break;
 case PZERO:
 case NZERO:
 case NORM: normal_fmac(m,n); break;
 } break;
 case PZERO:
 case NZERO: switch (data_type_of(m)){
case PINF:
 case NINF: invalid(n); break;
 case PZERO:
 case NZERO:
 case NORM: switch (data_type_of(n)){
 case DENORM: set_E(); break;
 case qNaN: qnan(n); break;
 case PZERO:
 case NZERO: zero(n,sign_of(0)^ sign_of(m)^sign_of(n)); break;
 default: break;
 } break;
 } break;
 case PINF :
 case NINF : switch (data_type_of(m)){
 case PZERO:
 case NZERO:invalid(n); break;
 default: switch (data_type_of(n)){
 case DENORM: set_E(); break;
 case qNaN: qnan(n); break;
 default: inf(n,sign_of(0)^sign_of(m)^sign_of(n));break
 } break;
 } break;
 }
}
void normal_fmac(int m,n)
{
union {
 int double x;
 int l[4];
} dstx,tmpx;
float dstf,srcf;
 if((data_type_of(n) == PZERO)|| (data_type_of(n) == NZERO))
 srcf = 0.0; /* flush denormalized value */
 else srcf = FR[n];
 tmpx.x = FR[0]; /* convert single to int double */
 tmpx.x *= FR[m]; /* exact product */
 dstx.x = tmpx.x + srcf;
 if(((dstx.x == srcf) && (tmpx.x != 0.0)) ||
 ((dstx.x == tmpx.x) && (srcf != 0.0))) {
 set_I();
 if(sign_of(0)^ sign_of(m)^ sign_of(n)) {
 dstx.l[3] -= 1; /* correct result */
 if(dstx.l[3] == 0xffffffff) dstx.l[2] -= 1;
 if(dstx.l[2] == 0xffffffff) dstx.l[1] -= 1;
 if(dstx.l[1] == 0xffffffff) dstx.l[0] -= 1;
 }
 else dstx.l[3] |= 1;
 }
 if((dstx.l[1] & 0x01ffffff) || dstx.l[2] || dstx.l[3]) set_I();
 if(FPSCR_RM == 1) {
 dstx.l[1] &= 0xfe000000; /* round toward zero */
 dstx.l[2] = 0x00000000;
 dstx.l[3] = 0x00000000;
 }
 dstf = dstx.x;
 check_single_exception(&FR[n],dstf);
}
void FMOV(int m,n) /* FMOV FRm,FRn */
{
 FR[n] = FR[m];
 pc += 2;
}
void FMOV_DR(int m,n) /* FMOV DRm,DRn */
{
 DR[n>>1] = DR[m>>1];
 pc += 2;
}
void FMOV_STORE(int m,n) /* FMOV.S FRm,@Rn */
{
 store_int(FR[m],R[n]);
 pc += 2;
}
void FMOV_STORE_DR(int m,n) /* FMOV DRm,@Rn */
{
 store_quad(DR[m>>1],R[n]);
 pc += 2;
}
 void FMOV_LOAD(int m,n) /* FMOV.S @Rm,FRn */
{
 load_int(R[m],FR[n]);
 pc += 2;
}
void FMOV_LOAD_DR(int m,n) /* FMOV @Rm,DRn */
{
 load_quad(R[m],DR[n>>1]);
 pc += 2;
}
void FMOV_RESTORE(int m,n) /* FMOV.S @Rm+,FRn */
{
 load_int(R[m],FR[n]);
 R[m] += 4;
 pc += 2;
}
void FMOV_RESTORE_DR(int m,n) /* FMOV @Rm+,DRn */
{
 load_quad(R[m],DR[n>>1]) ;
 R[m] += 8;
 pc += 2;
}
void FMOV_SAVE(int m,n) /* FMOV.S FRm,@–Rn */
{
 store_int(FR[m],R[n]-4);
 R[n] -= 4;
 pc += 2;
}
void FMOV_SAVE_DR(int m,n) /* FMOV DRm,@–Rn */
{
 store_quad(DR[m>>1],R[n]-8);
 R[n] -= 8;
 pc += 2;
}
void FMOV_INDEX_LOAD(int m,n) /* FMOV.S @(R0,Rm),FRn */
{
 load_int(R[0] + R[m],FR[n]);
 pc += 2;
}
void FMOV_INDEX_LOAD_DR(int m,n) /*FMOV @(R0,Rm),DRn */
{
 load_quad(R[0] + R[m],DR[n>>1]);
 pc += 2;
}
void FMOV_INDEX_STORE(int m,n) /*FMOV.S FRm,@(R0,Rn)*/
{
 store_int(FR[m], R[0] + R[n]);
 pc += 2;
}
void FMOV_INDEX_STORE_DR(int m,n)/*FMOV DRm,@(R0,Rn)*/
{
 store_quad(DR[m>>1], R[0] + R[n]);
 pc += 2;
}
void FMOV_STORE_XD(int m,n) /* FMOV XDm,@Rn */
{
 store_quad(XD[m>>1],R[n]);
 pc += 2;
}
void FMOV_LOAD_XD(int m,n) /* FMOV @Rm,XDn */
{
load_quad(R[m],XD[n>>1]);
pc += 2;
}
void FMOV_RESTORE_XD(int m,n) /* FMOV @Rm+,DBn */
{
load_quad(R[m],XD[n>>1]);
R[m] += 8;
pc += 2;
}
void FMOV_SAVE_XD(int m,n) /* FMOV XDm,@–Rn */
{
store_quad(XD[m>>1],R[n]-8);
R[n] -= 8;
pc += 2;
}
void FMOV_INDEX_LOAD_XD(int m,n) /* FMOV @(R0,Rm),XDn */
{
load_quad(R[0] + R[m],XD[n>>1]);
pc += 2;
}
void FMOV_INDEX_STORE_XD(int m,n) /* FMOV XDm,@(R0,Rn) */
{
 store_quad(XD[m>>1], R[0] + R[n]);
 pc += 2;
}
 void FMOV_XDXD(int m,n) /* FMOV XDm,XDn */
{
 XD[n>>1] = XD[m>>1];
 pc += 2;
}
void FMOV_XDDR(int m,n) /* FMOV XDm,DRn */
{
 DR[n>>1] = XD[m>>1];
 pc += 2;
}
void FMOV_DRXD(int m,n) /* FMOV DRm,XDn */
{
 XD[n>>1] = DR[m>>1];
 pc += 2;
}
void FMUL(int m,n)
{
 pc += 2;
 clear_cause();
 if((data_type_of(m) == sNaN) ||
 (data_type_of(n) == sNaN)) invalid(n);
 else if((data_type_of(m) == qNaN) ||
 (data_type_of(n) == qNaN)) qnan(n);
 else if((data_type_of(m) == DENORM) ||
 (data_type_of(n) == DENORM)) set_E();
 else switch (data_type_of(m){
 case NORM: switch (data_type_of(n)){
 case PZERO:
 case NZERO: zero(n,sign_of(m)^sign_of(n)); break;
 case PINF:
 case NINF: inf(n,sign_of(m)^sign_of(n)); break;
 default: normal_fmul(m,n); break;
 } break;
 case PZERO:
 case NZERO: switch (data_type_of(n)){
 case PINF:
 case NINF: invalid(n); break;
 default: zero(n,sign_of(m)^sign_of(n));break;
 } break;
 case PINF :
 case NINF : switch (data_type_of(n)){
 case PZERO:
 case NZERO: invalid(n); break;
 default: inf(n,sign_of(m)^sign_of(n));break
 } break;
 }
}
void FNEG (int n){
 FR[n] = -FR[n];
 pc += 2;
}
void FRCHG() /* FRCHG */
{
 if(FPSCR_PR == 0){
 FPSCR ^= 0x00200000; /* bit 21 */
 PC += 2;
 }
 else undefined_operation();
}
void FSCHG() /* FSCHG */
{
 if(FPSCR_PR == 0){
 FPSCR ^= 0x00100000; /* bit 20 */
 PC += 2;
 }
 else undefined_operation();
}
void FSQRT(int n){
 pc += 2;
 clear_cause();
 switch(data_type_of(n)){
 case NORM : if(sign_of(n) == 0) normal_ fsqrt(n);
 else invalid(n); break;
 case DENORM: if(sign_of(n) == 0) set_E();
 else invalid(n); break;
 case PZERO :
 case NZERO :
 case PINF : break;
 case NINF : invalid(n); break;
 case qNaN : qnan(n); break;
 case sNaN : invalid(n); break;
 }
}
void normal_fsqrt(int n)
{
union {
 float f;
 int l;
} dstf,tmpf;
union {
 double d;
 int l[2];
} dstd,tmpd;
union {
 int double x;
 int l[4];
} tmpx;
 if(FPSCR_PR == 0) {
 tmpf.f = FR[n]; /* save destination value */
 dstf.f = sqrt(FR[n]); /* round toward nearest or even */
 tmpd.d = dstf.f; /* convert single to double */
 tmpd.d *= dstf.f;
 if(tmpf.f != tmpd.d) set_I();
 if((tmpf.f < tmpd.d) && (SPSCR_RM == 1))
 dstf.l -= 1; /* round toward zero */
 if(FPSCR & ENABLE_I) fpu_exception_trap();
 else FR[n] = dstf.f;
 }else {
 tmpd.d = DR[n>>1]; /* save destination value */
 dstd.d = sqrt(DR[n>>1]); /* round toward nearest or even */
 tmpx.x = dstd.d; /* convert double to int double */
 tmpx.x *= dstd.d;
 if(tmpd.d != tmpx.x) set_I();
 if((tmpd.d < tmpx.x) && (SPSCR_RM == 1)) {
 dstd.l[1] -= 1; /* round toward zero */
 if(dstd.l[1] == 0xffffffff) dstd.l[0] -= 1;
 }
 if(FPSCR & ENABLE_I) fpu_exception_trap();
 else DR[n>>1] = dstd.d;
 }
}
void FSTS(int n, float *FPUL)
{
 FR[n] = *FPUL;
 pc += 2;
}
void FSUB (int m,n)
{
 pc += 2;
 clear_cause();
 if((data_type_of(m) == sNaN) ||
 (data_type_of(n) == sNaN)) invalid(n);
 else if((data_type_of(m) == qNaN) ||
 (data_type_of(n) == qNaN)) qnan(n);
 else if((data_type_of(m) == DENORM) ||
 (data_type_of(n) == DENORM)) set_E();
 else switch (data_type_of(m)){
 case NORM: switch (data_type_of(n)){
 case NORM: normal_faddsub(m,n,SUB); break;
 case PZERO:
 case NZERO: register_copy(m,n); FR[n] = -FR[n];break;
 default: break;
 } break;
 case PZERO: break;
 case NZERO: switch (data_type_of(n)){
 case NZERO: zero(n,0); break;
 default: break;
 } break;
 case PINF: switch (data_type_of(n)){
 case PINF: invalid(n); break;
 default: inf(n,1); break;
 } break;
 case NINF: switch (data_type_of(n)){
 case NINF: invalid(n); break;
 default: inf(n,0); break;
 } break;
 }
}
#define N_INT_SINGLE_RANGE 0xcf000000 & 0x7fffffff /* -1.000000 * 2^31 */
#define P_INT_SINGLE_RANGE 0x4effffff /* 1.fffffe * 2^30 */
#define N_INT_DOUBLE_RANGE 0xc1e0000000200000 & 0x7fffffffffffffff
#define P_INT_DOUBLE_RANGE 0x41e0000000000000
void FTRC(int m, int *FPUL)
{
 pc += 2;
 clear_cause();
 if(FPSCR.PR==0){
 case(ftrc_single_ type_of(m)){
 NORM: *FPUL = FR[m]; break;
 PINF: ftrc_invalid(0); break;
 NINF: ftrc_invalid(1); break;
 }
 }
 else{ /* case FPSCR.PR=1 */
 case(ftrc_double_type_of(m)){
 NORM: *FPUL = DR[m>>1]; break;
 PINF: ftrc_invalid(0); break;
 NINF: ftrc_invalid(1); break;
 }
 }
}
int ftrc_signle_type_of(int m)
{
 if(sign_of(m) == 0){
 if(FR_HEX[m] > 0x7f800000) return(NINF); /* NaN */
 else if(FR_HEX[m] > P_INT_SINGLE_RANGE)
 return(PINF); /* out of range,+INF */
 else return(NORM); /* +0,+NORM */
 }else {
 if((FR_HEX[m] & 0x7fffffff) > N_INT_SINGLE_RANGE)
 return(NINF); /* out of range ,+INF,NaN*/
 else return(NORM); /* -0,-NORM */
 }
}
int ftrc_double_type_of(int m)
{
 if(sign_of(m) == 0){
 if((FR_HEX[m] > 0x7ff00000) ||
 ((FR_HEX[m] == 0x7ff00000) &&
 (FR_HEX[m+1] != 0x00000000))) return(NINF); /* NaN */
 else if(DR_HEX[m>>1] >= P_INT_DOUBLE_RANGE)
 return(PINF); /* out of range,+INF */
 else return(NORM); /* +0,+NORM */
 }else {
 if((DR_HEX[m>>1] & 0x7fffffffffffffff) >= N_INT_DOUBLE_RANGE)
 return(NINF); /* out of range ,+INF,NaN*/
 else return(NORM); /* -0,-NORM */
 }
}
void ftrc_invalid(int sign, int *FPUL)
{
 set_V();
 if((FPSCR & ENABLE_V) == 0){
 if(sign == 0) *FPUL = 0x7fffffff;
 else *FPUL = 0x80000000;
 }
 else fpu_exception_trap();
}
void FTRV (int n) /* FTRV FVn */
{
float saved_vec[4],result_vec[4];
int saved_fpscr;
int dst,i;
 if(FPSCR_PR == 0) {
 PC += 2;
 clear_cause();
 saved_fpscr = FPSCR;
 FPSCR &= ~ENABLE_VOUI; /* mask VOUI enable */
 dst = 12 - n; /* select other vector than FVn */
 for(i=0;i<4;i++)saved_vec [i] = FR[dst+i];
 for(i=0;i<4;i++){
 for(j=0;j<4;j++) FR[dst+j] = XF[i+4j];
 fipr(n,dst);
 saved_fpscr |= FPSCR & (CAUSE|FLAG) ;
 result_vec [i] = FR[dst+3];
 }
 for(i=0;i<4;i++)FR[dst+i] = saved_vec [i];
 FPSCR = saved_fpscr;
 if(FPSCR & ENABLE_VOUI) fpu_exception_trap();
 else for(i=0;i<4;i++) FR[n+i] = result_vec [i];
 }
 else undefined_operation();
}
JMP(int n)/* JMP @Rn */
{
 unsigned int temp;
 temp=PC;
 PC=R[n];
 Delay_Slot(temp+2);
}
JSR(int n)/* JSR @Rn */
{
 unsigned int temp;
 temp=PC;
 PR=PC+4;
 PC=R[n];
 Delay_Slot(temp+2);
}
LDCSR(int m) /* LDC Rm,SR : Privileged */
 {
 SR=R[m]&0x700083F3;
 PC+=2;
 }
 LDCGBR(int m) /* LDC Rm,GBR */
 {
 GBR=R[m];
 PC+=2;
 }
 LDCVBR(int m) /* LDC Rm,VBR : Privileged */
 {
 VBR=R[m];
 PC+=2;
 }
 LDCSSR(int m) /* LDC Rm,SSR : Privileged */
 {
 SSR=R[m],
 PC+=2;
 }
 LDCSPC(int m) /* LDC Rm,SPC : Privileged */
 {
 SPC=R[m];
PC+=2;
 }
 LDCDBR(int m) /* LDC Rm,DBR : Privileged */
 {
 DBR=R[m];
 PC+=2;
 }
 LDCRn_BANK(int m) /* LDC Rm,Rn_BANK : Privileged */
 /* n=0–7 */
 {
 Rn_BANK=R[m];
 PC+=2;
 }
 LDCMSR(int m) /* LDC.L @Rm+,SR : Privileged */
 {
 SR=Read_Long(R[m])&0x700083F3;
 R[m]+=4;
 PC+=2;
 }
 LDCMGBR(int m) /* LDC.L @Rm+,GBR */
 {
 GBR=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
 }
 LDCMVBR(int m) /* LDC.L @Rm+,VBR : Privileged */
 {
 VBR=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
 }
LDCMSSR(int m) /* LDC.L @Rm+,SSR : Privileged */
 {
 SSR=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
 }
 LDCMSPC(int m) /* LDC.L @Rm+,SPC : Privileged */
 {
 SPC=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
 }
 LDCMDBR(int m) /* LDC.L @Rm+,DBR : Privileged */
 {
 DBR=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
 }
 LDCMRn_BANK(Long m) /* LDC.L @Rm+,Rn_BANK : Privileged */
 /* n=0–7 */
 {
 Rn_BANK=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
 }
#define FPSCR_MASK 0x003FFFFF
LDSFPUL(int m, int *FPUL) /* LDS Rm,FPUL */
{
 *FPUL=R[m];
 PC+=2;
}
LDSMFPUL(int m, int *FPUL) /* LDS.L @Rm+,FPUL */
{
 *FPUL=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
}
LDSFPSCR(int m) /* LDS Rm,FPSCR */
{
 FPSCR=R[m] & FPSCR_MASK;
 PC+=2;
}
LDSMFPSCR(int m) /* LDS.L @Rm+,FPSCR */
{
 FPSCR=Read_Long(R[m]) & FPSCR_MASK;
 R[m]+=4;
 PC+=2;
}
LDSMACH(int m) /* LDS Rm,MACH */
{
 MACH=R[m];
 PC+=2;
}
LDSMACL(int m) /* LDS Rm,MACL */
{
 MACL=R[m];
 PC+=2;
}
LDSPR(int m) /* LDS Rm,PR */
{
 PR=R[m];
 PC+=2;
}
LDSMMACH(int m) /* LDS.L @Rm+,MACH */
{ MACH=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
}
LDSMMACL(int m) /* LDS.L @Rm+,MACL */
{
 MACL=Read_Long(R[m]);
 R[m]+=4;
 PC+=2;
}

void LDSMPR(CPU *cpu, int m) /* LDS.L @Rm+,PR */
{
 cpu->PR=read_word(cpu, cpu->GR[m]);
 cpu->GR[m]+=4;
 cpu->PC+=2;
}

LDTLB( ) /*LDTLB */
{
 TLB[MMUCR. URC] .ASID=PTEH & 0x000000FF;
 TLB[MMUCR. URC] .VPN=(PTEH & 0xFFFFFC00)>>10;
 TLB[MMUCR. URC] .PPN=(PTEH & 0x1FFFFC00)>>10;
 TLB[MMUCR. URC] .SZ=(PTEL & 0x00000080)>>6 |
 (PTEL & 0x00000010)>>4;
 TLB[MMUCR. URC] .SH=(PTEH & 0x00000002)>>1;
 TLB[MMUCR. URC] .PR=(PTEH & 0x00000060)>>5;
 TLB[MMUCR. URC] .WT=(PTEH & 0x00000001);
 TLB[MMUCR. URC] .C=(PTEH & 0x00000008)>>3;
 TLB[MMUCR. URC] .D=(PTEH & 0x00000004)>>2;
 TLB[MMUCR. URC] .V=(PTEH & 0x00000100)>>8;
 TLB[MMUCR. URC] .SA=(PTEA & 0x00000007);
 TLB[MMUCR. URC] .TC=(PTEA & 0x00000008)>>3;
 PC+=2;
}
MACL(long m, long n) /* MAC.L @Rm+,@Rn+ */
{
 unsigned long RnL,RnH,RmL,RmH,Res0,Res1,Res2;
 unsigned long temp0,temp1,temp2,temp3;
 long tempm,tempn,fnLmL;
 tempn=(long)Read_Long(R[n]);
 R[n]+=4;
 tempm=(long)Read_Long(R[m]);
 R[m]+=4;
 if ((long)(tempn^tempm)<0) fnLmL=-1;
 else fnLmL=0;
 if (tempn<0) tempn=0-tempn;
 if (tempm<0) tempm=0-tempm;
 temp1=(unsigned long)tempn;
 temp2=(unsigned long)tempm;
 RnL=temp1&0x0000FFFF;
 RnH=(temp1>>16)&0x0000FFFF;
 RmL=temp2&0x0000FFFF;
 RmH=(temp2>>16)&0x0000FFFF;
 temp0=RmL*RnL;
 temp1=RmH*RnL;
 temp2=RmL*RnH;
 temp3=RmH*RnH;
 Res2=0;
Res1=temp1+temp2;
if (Res1<temp1) Res2+=0x00010000;
temp1=(Res1<<16)&0xFFFF0000;
Res0=temp0+temp1;
if (Res0<temp0) Res2++;
Res2=Res2+((Res1>>16)&0x0000FFFF)+temp3;
if(fnLmL<0){
 Res2=~
Res2;
 if (Res0==0) Res2++;
 else Res0=(~
Res0)+1;
}
if(S==1){
 Res0=MACL+Res0;
 if (MACL>Res0) Res2++;
 if (MACH&0x00008000);
 else Res2+=MACH|0xFFFF0000;
 Res2+=MACH&0x00007FFF;
 if(((long)Res2<0)&&(Res2<0xFFFF8000)){
 Res2=0xFFFF8000;
 Res0=0x00000000;
 }
 if(((long)Res2>0)&&(Res2>0x00007FFF)){
 Res2=0x00007FFF;
 Res0=0xFFFFFFFF;
 };
 MACH=(Res2&0x0000FFFF)|(MACH&0xFFFF0000);
 MACL=Res0;
}
 else {
 Res0=MACL+Res0;
 if (MACL>Res0) Res2++;
 Res2+=MACH;
 MACH=Res2;
 MACL=Res0;
 }
 PC+=2;
}
MACW(long m, long n) /* MAC.W @Rm+,@Rn+ */
{
 long tempm,tempn,dest,src,ans;
 unsigned long templ;
 tempn=(long)Read_Word(R[n]);
 R[n]+=2;
 tempm=(long)Read_Word(R[m]);
 R[m]+=2;
 templ=MACL;
 tempm=((long)(short)tempn*(long)(short)tempm);
 if ((long)MACL>=0) dest=0;
 else dest=1;
 if ((long)tempm>=0) {
 src=0;
 tempn=0;
 }
 else {
 src=1;
 tempn=0xFFFFFFFF;
 }
 src+=dest;
 MACL+=tempm;
 if ((long)MACL>=0) ans=0;
 else ans=1;
 ans+=dest;
 if (S==1) {
 if (ans==1) {
 if (src==0) MACL=0x7FFFFFFF;
 if (src==2) MACL=0x80000000;
 }
 }
 else {
 MACH+=tempn;
 if (templ>MACL) MACH+=1;
 }
 PC+=2;
}

MOV(long m, long n) /* MOV Rm,Rn */
{
 R[n]=R[m];
 PC+=2;
}
MOVBS(long m, long n) /* MOV.B Rm,@Rn */
{
 Write_Byte(R[n],R[m]);
 PC+=2;
}
MOVWS(long m, long n) /* MOV.W Rm,@Rn */
{
 Write_Word(R[n],R[m]);
 PC+=2;
}
MOVLS(long m, long n) /* MOV.L Rm,@Rn */
{
 Write_Long(R[n],R[m]);
 PC+=2;
}
MOVBL(long m, long n) /* MOV.B @Rm,Rn */
{
 R[n]=(long)Read_Byte(R[m]);
 if ((R[n]&0x80)==0) R[n]&=0x000000FF;
 else R[n]|=0xFFFFFF00;
 PC+=2;
}
MOVWL(long m, long n) /* MOV.W @Rm,Rn */
{
 R[n]=(long)Read_Word(R[m]);
 if ((R[n]&0x8000)==0) R[n]&=0x0000FFFF;
 else R[n]|=0xFFFF0000;
 PC+=2;
}
MOVLL(long m, long n) /* MOV.L @Rm,Rn */
}
 R[n]=Read_Long(R[m]);
 PC+=2;
}
MOVBM(long m, long n) /* MOV.B Rm,@-Rn */
{
 Write_Byte(R[n]-1,R[m]);
 R[n]-=1;
 PC+=2;
}
MOVWM(long m, long n) /* MOV.W Rm,@-Rn */
{
 Write_Word(R[n]-2,R[m]);
 R[n]-=2;
 PC+=2;
}
MOVLM(long m, long n) /* MOV.L Rm,@-Rn */
{
 Write_Long(R[n]-4,R[m]);
 R[n]-=4;
 PC+=2;
}
MOVBP(long m, long n) /* MOV.B @Rm+,Rn */
{
 R[n]=(long)Read_Byte(R[m]);
 if ((R[n]&0x80)==0) R[n]&=0x000000FF;
 else R[n]|=0xFFFFFF00;
 if (n!=m) R[m]+=1;
 PC+=2;
}
MOVWP(long m, long n) /* MOV.W @Rm+,Rn */
{
 R[n]=(long)Read_Word(R[m]);
 if ((R[n]&0x8000)==0) R[n]&=0x0000FFFF;
 else R[n]|=0xFFFF0000;
 if (n!=m) R[m]+=2;
 PC+=2;
}
MOVLP(long m, long n) /* MOV.L @Rm+,Rn */
{
 R[n]=Read_Long(R[m]);
 if (n!=m) R[m]+=4;
 PC+=2;
}
MOVBS0(long m, long n) /* MOV.B Rm,@(R0,Rn) */
{
 Write_Byte(R[n]+R[0],R[m]);
 PC+=2;
}
MOVWS0(long m, long n) /* MOV.W Rm,@(R0,Rn) */
{
 Write_Word(R[n]+R[0],R[m]);
 PC+=2;
}
MOVLS0(long m, long n) /* MOV.L Rm,@(R0,Rn) */
{
 Write_Long(R[n]+R[0],R[m]);
 PC+=2;
}
MOVBL0(long m, long n) /* MOV.B @(R0,Rm),Rn */
{
 R[n]=(long)Read_Byte(R[m]+R[0]);
 if ((R[n]&0x80)==0) R[n]&=0x000000FF;
 else R[n]|=0xFFFFFF00;
 PC+=2;
}
MOVWL0(long m, long n) /* MOV.W @(R0,Rm),Rn */
{
 R[n]=(long)Read_Word(R[m]+R[0]);
 if ((R[n]&0x8000)==0) R[n]&=0x0000FFFF;
 else R[n]|=0xFFFF0000;
 PC+=2;
}
MOVLL0(long m, long n) /* MOV.L @(R0,Rm),Rn */
{
 R[n]=Read_Long(R[m]+R[0]);
 PC+=2;
}
MOVI(int i, int n) /* MOV #imm,Rn */
{
 if ((i&0x80)==0) R[n]=(0x000000FF & i);
 else R[n]=(0xFFFFFF00 | i);
 PC+=2;
}
MOVWI(d, n) /* MOV.W @(disp,PC),Rn */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 R[n]=(int)Read_Word(PC+4+(disp<<1));
 if ((R[n]&0x8000)==0) R[n]&=0x0000FFFF;
 else R[n]|=0xFFFF0000;
 PC+=2;
}
 MOVLI(int d, int n)/* MOV.L @(disp,PC),Rn */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & (int)d);
 R[n]=Read_Long((PC&0xFFFFFFFC)+4+(disp<<2));
 PC+=2;
}
MOVBLG(int d) /* MOV.B @(disp,GBR),R0 */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 R[0]=(int)Read_Byte(GBR+disp);
 if ((R[0]&0x80)==0) R[0]&=0x000000FF;
 else R[0]|=0xFFFFFF00;
 PC+=2;
}
MOVWLG(int d) /* MOV.W @(disp,GBR),R0 */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 R[0]=(int)Read_Word(GBR+(disp<<1));
 if ((R[0]&0x8000)==0) R[0]&=0x0000FFFF;
 else R[0]|=0xFFFF0000;
 PC+=2;
}
MOVLLG(int d) /* MOV.L @(disp,GBR),R0 */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 R[0]=Read_Long(GBR+(disp<<2));
 PC+=2;
}
MOVBSG(int d) /* MOV.B R0,@(disp,GBR) */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 Write_Byte(GBR+disp,R[0]);
 PC+=2;
}
MOVWSG(int d) /* MOV.W R0,@(disp,GBR) */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 Write_Word(GBR+(disp<<1),R[0]);
 PC+=2;
}
MOVLSG(int d) /* MOV.L R0,@(disp,GBR) */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & (long)d);
 Write_Long(GBR+(disp<<2),R[0]);
 PC+=2;
}
MOVBS4(long d, long n /* MOV.B R0,@(disp,Rn) */
{
 long disp;
 disp=(0x0000000F & (long)d);
 Write_Byte(R[n]+disp,R[0]);
 PC+=2;
}
MOVWS4(long d, long n) /* MOV.W R0,@(disp,Rn) */
{
 long disp;
 disp=(0x0000000F & (long)d);
 Write_Word(R[n]+(disp<<1),R[0]);
 PC+=2;
}
MOVLS4(long m, long d, long n) /* MOV.L Rm,@(disp,Rn) */
{
 long disp;
 disp=(0x0000000F & (long)d);
 Write_Long(R[n]+(disp<<2),R[m]);
 PC+=2;
}
MOVBL4(long m, long d) /* MOV.B @(disp,Rm),R0 */
{
 long disp;
 disp=(0x0000000F & (long)d);
 R[0]=Read_Byte(R[m]+disp);
 if ((R[0]&0x80)==0) R[0]&=0x000000FF;
 else R[0]|=0xFFFFFF00;
 PC+=2;
}
MOVWL4(long m, long d) /* MOV.W @(disp,Rm),R0 */
{
 long disp;
 disp=(0x0000000F & (long)d);
 R[0]=Read_Word(R[m]+(disp<<1));
 if ((R[0]&0x8000)==0) R[0]&=0x0000FFFF;
 else R[0]|=0xFFFF0000;
 PC+=2;
}
MOVLL4(long m, long d, long n) /* MOV.L @(disp,Rm),Rn */
{
 long disp;
 disp=(0x0000000F & (long)d);
 R[n]=Read_Long(R[m]+(disp<<2));
 PC+=2;
}
MOVA(int d) /* MOVA @(disp,PC),R0 */
{
 unsigned int disp;
 disp=(unsigned int)(0x000000FF & d);
 R[0]=(PC&0xFFFFFFFC)+4+(disp<<2);
 PC+=2;
}
MOVCAL(int n) /*MOVCA.L R0,@Rn */
 {
 if ((is_write_back_memory(R[n]))
 && (look_up_in_operand_cache(R[n]) == MISS))
 allocate_operand_cache_block(R[n]);
 Write_Long(R[n], R[0]);
 PC+=2;
 }
MOVT(long n) /* MOVT Rn */
{
 R[n]=(0x00000001 & SR);
 PC+=2;
}
MULL(long m, long n) /* MUL.L Rm,Rn */
{
 MACL=R[n]*R[m];
 PC+=2;
}
MULS(long m, long n) /* MULS Rm,Rn */
{
 MACL=((long)(short)R[n]*(long)(short)R[m]);
 PC+=2;
}
MULU(long m, long n) /* MULU Rm,Rn */
{
 MACL=((unsigned long)(unsigned short)R[n]*
 (unsigned long)(unsigned short)R[m];
 PC+=2;
}
NEG(long m, long n) /* NEG Rm,Rn */
{
 R[n]=0-R[m];
 PC+=2;
}
NEGC(long m, long n) /* NEGC Rm,Rn */
{
 unsigned long temp;
 temp=0-R[m];
 R[n]=temp-T;
 if (0<temp) T=1;
 else T=0;
 if (temp<R[n]) T=1;
 PC+=2;
}
NOP( ) /* NOP */
{
 PC+=2;
}
NOT(long m, long n) /* NOT Rm,Rn */
{
 R[n]=∼R[m];
 PC+=2;
}
OCBI(int n) /* OCBI @Rn */
{
 invalidate_operand_cache_block(R[n]);
 PC+=2;
}
OCBP(int n) /* OCBP @Rn */
{
 if(is_dirty_block(R[n])) write_back(R[n])
 invalidate_operand_cache_block(R[n]);
 PC+=2;
}

OCBWB(int n) /* OCBWB @Rn */
 {
 if(is_dirty_block(R[n])) write_back(R[n]);
 PC+=2;
 }
OR(long m, long n) /* OR Rm,Rn */
{
 R[n]|=R[m];
 PC+=2;
}
ORI(long i) /* OR #imm,R0 */
{
 R[0]|=(0x000000FF & (long)i);
 PC+=2;
}
ORM(long i) /* OR.B #imm,@(R0,GBR) */
{
 long temp;
 temp=(long)Read_Byte(GBR+R[0]);
 temp|=(0x000000FF & (long)i);
 Write_Byte(GBR+R[0],temp);
 PC+=2;
}
PREF(int n) /* PREF */
{
 PC+=2;
}

ROTCL(long n) /* ROTCL Rn */
{
 long temp;
 if ((R[n]&0x80000000)==0) temp=0;
 else temp=1;
 R[n]<<=1;
 if (T==1) R[n]|=0x00000001;
 else R[n]&=0xFFFFFFFE;
 if (temp==1) T=1;
 else T=0;
 PC+=2;
}
ROTCR(long n) /* ROTCR Rn */
{
 long temp;
 if ((R[n]&0x00000001)==0) temp=0;
 else temp=1;
 R[n]>>=1;
 if (T==1) R[n]|=0x80000000;
 else R[n]&=0x7FFFFFFF;
 if (temp==1) T=1;
 else T=0;
 PC+=2;
}
ROTL(long n) /* ROTL Rn */
{
 if ((R[n]&0x80000000)==0) T=0;
 else T=1;
 R[n]<<=1;
 if (T==1) R[n]|=0x00000001;
 else R[n]&=0xFFFFFFFE;
 PC+=2;
}
ROTR(long n) /* ROTR Rn */
{
 if ((R[n]&0x00000001)==0) T=0;
 else T=1;
 R[n]>>=1;
 if (T==1) R[n]|=0x80000000;
 else R[n]&=0x7FFFFFFF;
 PC+=2;
}
RTE( ) /* RTE */
{
 unsigned int temp;
 temp=PC;
 SR=SSR;
 PC=SPC;
 Delay_Slot(temp+2);
}
RTS( ) /* RTS */
{
 unsigned int temp;
 temp=PC;
 PC=PR;
 Delay_Slot(temp+2);
}
SETS( ) /* SETS */
{
 S=1;
 PC+=2;
}
SETT( ) /* SETT */
{
 T=1;
 PC+=2;
}
SHAD(int m,n) /*SHAD Rm,Rn */
{
 int sgn=R[m] & 0x80000000;
 if (sgn==0)
 R[n] <<= (R[m] & 0x1F);
 else if ((R[m] & 0x1F) == 0) {
 if ((R[n] & 0x80000000) == 0)
 R[n] = 0;
 else
 R[n] = 0xFFFFFFFF;
 }
 else
 R[n]=(long)R[n] >> ((~R[m] & 0x1F)+1);
 PC+=2;
}
SHAL(long n) /* SHAL Rn (Same as SHLL) */
{
 if ((R[n]&0x80000000)==0) T=0;
 else T=1;
 R[n]<<=1;
 PC+=2;
}
SHAR(long n) /* SHAR Rn */
{
 long temp;
 if ((R[n]&0x00000001)==0) T=0;
 else T=1;
 if ((R[n]&0x80000000)==0) temp=0;
 else temp=1;
 R[n]>>=1;
 if (temp==1) R[n]|=0x80000000;
 else R[n]&=0x7FFFFFFF;
 PC+=2;
}
SHLD(int m,n)/*SHLD Rm,Rn */
{
 int sgn = R[m] & 0x80000000;
 if (sgn == 0)
 R[n] <<= (R[m] & 0x1F);
 else if ((R[m] & 0x1F) == 0)
 R[n] = 0;
 else
 R[n]=(unsigned)R[n] >> ((~R[m] & 0x1F)+1);
 PC+=2;
}
SHLL(long n) /* SHLL Rn (Same as SHAL) */
{
 if ((R[n]&0x80000000)==0) T=0;
 else T=1;
 R[n]<<=1;
 PC+=2;
}
SHLL2(long n) /* SHLL2 Rn */
{
 R[n]<<=2;
 PC+=2;
}
SHLL8(long n) /* SHLL8 Rn */
{
 R[n]<<=8;
 PC+=2;
}
SHLL16(long n) /* SHLL16 Rn */
{
 R[n]<<=16;
 PC+=2;
}
SHLR(long n) /* SHLR Rn */
{
 if ((R[n]&0x00000001)==0) T=0;
 else T=1;
 R[n]>>=1;
 R[n]&=0x7FFFFFFF;
 PC+=2;
}
SHLR2(long n) /* SHLR2 Rn */
{
 R[n]>>=2;
 R[n]&=0x3FFFFFFF;
 PC+=2;
}
SHLR8(long n) /* SHLR8 Rn */
{
 R[n]>>=8;
 R[n]&=0x00FFFFFF;
 PC+=2;
}
SHLR16(long n) /* SHLR16 Rn */
{
 R[n]>>=16;
 R[n]&=0x0000FFFF;
 PC+=2;
}
SLEEP( ) /* SLEEP */
{
 Sleep_standby();
}
STCSR(int n) /* STC SR,Rn : Privileged */
 {
 R[n]=SR;
 PC+=2;
 }
STCGBR(int n) /* STC GBR,Rn */
 {
 R[n]=SGR;
 PC+=2;
 }
STCVBR(int n) /* STC VBR,Rn : Privileged */
 {
 R[n]=VBR;
 PC+=2;
 }
STCSSR(int n) /* STC SSR,Rn : Privileged */
 {
 R[n]=SSR;
 PC+=2;
 }
STCSPC(int n) /* STC SPC,Rn : Privileged */
 {
 R[n]=SPC;
 PC+=2;
 }
STCSGR(int n) /* STC SGR,Rn : Privileged */
 {
 R[n]=SGR;
 PC+=2;
 }
STCDBR(int n) /* STC DBR,Rn : Privileged */
 {
 R[n]=DBR;
 PC+=2;
 }
STCRm_BANK(int n) /* STC Rm_BANK,Rn : Privileged */
 /* m=0–7 */
 {
 R[n]=Rm_BANK;
 PC+=2;
 }
STCMSR(int n) /* STC.L SR,@-Rn : Privileged */
 {
 R[n]–=4;
 Write_Long(R[n],SR);
 PC+=2;
 }
STCMGBR(int n) /* STC.L GBR,@–Rn */
 {
 R[n]–=4;
 Write_Long(R[n],GBR);
 PC+=2;
 }
STCMVBR(int n) /* STC.L VBR,@-Rn : Privileged */
 {
 R[n]–=4;
 Write_Long(R[n],VBR);
 PC+=2;
 }
STCMSSR(int n) /* STC.L SSR,@-Rn : Privileged */
 {
 R[n]–=4;
 Write_Long(R[n],SSR);
 PC+=2;
 }
STCMSPC(int n) /* STC.L SPC,@-Rn : Privileged */
 {
 R[n]–=4;
 Write_Long(R[n],SPC);
 PC+=2;
 }
STCMSGR(int n) /* STC.L SGR,@-Rn : Privileged */
 {
 R[n]–=4;
 Write_Long(R[n],SGR);
 PC+=2;
 }
STCMDBR(int n) /* STC.L DBR,@-Rn : Privileged */
 {
 R[n]–=4;
 Write_Long(R[n],DBR);
 PC+=2;
 }
STCMRm_BANK(int n) /* STC.L Rm_BANK,@-Rn : Privileged */
 /* m=0–7 */
 {
 R[n]–=4;
 Write_Long(R[n],Rm_BANK);
 PC+=2;
 }
STSMACH(int n) /* STS MACH,Rn */
{
 R[n]=MACH;
 PC+=2;
}
STSMACL(int n) /* STS MACL,Rn */
{
 R[n]=MACL;
 PC+=2;
}
STSPR(int n) /* STS PR,Rn */
{
 R[n]=PR;
 PC+=2;
}
STSMMACH(int n) /* STS.L MACH,@-Rn */
{
 R[n]–=4;
 Write_Long(R[n],MACH);
 PC+=2;
}
STSMMACL(int n) /* STS.L MACL,@-Rn */
{
 R[n]–=4;
 Write_Long(R[n],MACL);
 PC+=2;
}
STSMPR(int n) /* STS.L PR,@-Rn */
{
 R[n]–=4;
 Write_Long(R[n],PR);
 PC+=2;
}
STS(int n, int *FPUL) /* STS FPUL,Rn */
{
 R[n]= *FPUL;
 PC+=2;
}
STS_SAVE(int n, int *FPUL) /* STS.L FPUL,@-Rn */
{
 R[n]-=4;
 Write_Long(R[n],*FPUL) ;
 PC+=2;
}
STS(int n) /* STS FPSCR,Rn */
{
 R[n]=FPSCR&0x003FFFFF;
 PC+=2;
}
STS_RESTORE(int n) /* STS.L FPSCR,@-Rn */
{
 R[n]-=4;
 Write_Long(R[n],FPSCR&0x003FFFFF)
 PC+=2;
}
SUB(long m, long n) /* SUB Rm,Rn */
{
 R[n]-=R[m];
 PC+=2;
}

SUBC(long m, long n) /* SUBC Rm,Rn */
{
 unsigned long tmp0,tmp1;
 tmp1=R[n]-R[m];
 tmp0=R[n];
 R[n]=tmp1-T;
 if (tmp0<tmp1) T=1;
 else T=0;
 if (tmp1<R[n]) T=1;
 PC+=2;
}
SUBV(long m, long n) /* SUBV Rm,Rn */
{
 long dest,src,ans;
 if ((long)R[n]>=0) dest=0;
 else dest=1;
 if ((long)R[m]>=0) src=0;
 else src=1;
 src+=dest;
 R[n]-=R[m];
 if ((long)R[n]>=0) ans=0;
 else ans=1;
 ans+=dest;
 if (src==1) {
 if (ans==1) T=1;
 else T=0;
 }
 else T=0;
 PC+=2;
}
SWAPB(long m, long n) /* SWAP.B Rm,Rn */
{
 unsigned long temp0,temp1;
 temp0=R[m]&0xFFFF0000;
 temp1=(R[m]&0x000000FF)<<8;
 R[n]=(R[m]&0x0000FF00)>>8;
 R[n]=R[n]|temp1|temp0;
 PC+=2;
}
SWAPW(long m, long n) /* SWAP.W Rm,Rn */
{
 unsigned long temp;
 temp=(R[m]>>16)&0x0000FFFF;
 R[n]=R[m]<<16;
 R[n]|=temp;
 PC+=2;
}
TAS(int n) /* TAS.B @Rn */
{
 int temp;
 temp=(int)Read_Byte(R[n]); /* Bus Lock */
 if (temp==0) T=1;
 else T=0;
 temp|=0x00000080;
 Write_Byte(R[n],temp); /* Bus unlock */
 PC+=2;
}
TRAPA(int i) /* TRAPA #imm */
 {
 int imm;
 imm=(0x000000FF & i);
 TRA=imm<<2;
 SSR=SR;
 SPC=PC+2;
 SR.MD=1;
 SR.BL=1;
 SR.RB=1;
 EXPEVT=0x00000160;
 PC=VBR+H’00000100;
}
TST(long m, long n) /* TST Rm,Rn */
{
 if ((R[n]&R[m])==0) T=1;
 else T=0;
 PC+=2;
}
TSTI(long i) /* TST #imm,R0 */
{
 long temp;
 temp=R[0]&(0x000000FF & (long)i);
 if (temp==0) T=1;
 else T=0;
 PC+=2;
}
TSTM(long i) /* TST.B #imm,@(R0,GBR) */
{
 long temp;
 temp=(long)Read_Byte(GBR+R[0]);
 temp&=(0x000000FF & (long)i);
 if (temp==0) T=1;
 else T=0;
 PC+=2;
}
XOR(long m, long n) /* XOR Rm,Rn */
{
 R[n]^=R[m];
 PC+=2;
}
XORI(long i) /* XOR #imm,R0 */
{
 R[0]^=(0x000000FF & (long)i);
 PC+=2;
}
XORM(long i) /* XOR.B #imm,@(R0,GBR) */
{
 int temp;
 temp=(long)Read_Byte(GBR+R[0]);
 temp^=(0x000000FF &(long)i);
 Write_Byte(GBR+R[0],temp);
 PC+=2;
}
XTRCT(long m, long n) /* XTRCT Rm,Rn */
{
 unsigned long temp;
 temp=(R[m]<<16)&0xFFFF0000;
 R[n]=(R[n]>>16)&0x0000FFFF;
 R[n]|=temp;
 PC+=2;
}


